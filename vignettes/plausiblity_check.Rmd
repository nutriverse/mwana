---
title: "How to run plausibility check with `ipccheckr`?"
author: TomÃ¡s Zaba
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to run plausibility check with `ipccheckr`?}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  eval = TRUE
)

library(ipccheckr)
```

## Introduction

`ipccheckr` provides handy functions to run plausibility checks on anthropometric data, more specifically on weight-for-height z-score (WFHZ), MUAC-for-age z-score (MFAZ) and on the absolute MUAC alone. In this vignette, you will learn on how to use the `ipccheckr` functions to that end. A step-by-step approach is used from preparing you data to feed into *de facto* plausibility checkers, including on how to render an already formatted and ready-to-share/present output table. Throughout this vignette, you will also learn about when you should consider running MFAZ plausibility check over the absolute MUAC.

For the demonstration, an `ipccheckr` built-in sample data set named `anthro.01` will be used. This data set contains data on district level SMART surveys conducted in an anonymized location. You can check this data set's dictionary by calling `?anthro.01` in R's console.

Let's start the demonstration with the plausibility checks that, most likely, you are familiar with to the new ones. 

## Checking plausibility check on weight-for-height z-score

You check the plausibility of your WFHZ data by calling the `check_plausibility_wfhz()` function. But before calling it, you need to get your data into the "shape and format" that accepted by the function. Don't worry, you will learn how to get there. Just hold on for a second as we want to make you understand what the function does. 

`check_plausibility_wfhz()` is a replica of the plausibility check function in ENA for SMART software of the [SMART Methodology](https://smartmethodology.org/). Under the hood, it runs the same statistical tests you already know from SMART and applies the same classification and scoring criteria for each test. Two differences between the two is that (i) `check_plausibility_wfhz()` does not include MUAC in its check. This is simply because now you are able to run a more comprehensive plausibility check on MUAC as you described in the relevant sections below; (ii) `check_plausibility_wfhz()` allows you to run checks on a multiple area survey data at once, without having to repeat the same workflow one-by-one for the number of survey areas your data holds. 

Now that you know the key features of `check_plausibility_wfhz()`, we can now start delving into how to achieve your wish. 

Let's start by first inspecting the sample data. You can inspect the head or tail of the data. Let's check the tail of it. You can achieve that by doing this:

```{r usage.1, echo = TRUE, eval = FALSE}
tail(anthro.01)
```

This will return the following: 

```{r usage.1a, echo = FALSE}
tail(anthro.01)
```

As you see, the data set has eleven variable and it's structure is that of the ENA for SMART software. 

As mentioned somewhere above, before you give your data to `check_plausibility_wfhz()`, you have to process it into the format it accepts. There are two functions you have to use: `process_age()` and `process_wfhz_data()`. You can get acquainted with each functions parameters by calling `?process_age` or `?process_wfhz_data` in R console. 

### Getting age into right format with `process_age()`

You use `process_age()` to calculate age in months through the difference between survey data and birth date. it returns age in months with two decimal and they get stored within the same variable (age). For where age in months existed already, typical when a calendar of events is used to estimate age in months, `process_age` will leave that age untouched and fills the empty cells (where age in months is missing and both survey date and birth date are available). In addition, a new variable named **age_days** is added to the data set. This variable is mostly used in the MFAZ related checks. 

You use `process_age()` as follows: 

```{r usage.2, echo = TRUE, eval = FALSE}
age_mo <- process_age(
  df = anthro.01,
  svdate = "dos",
  birdate = "dob",
  age = age
)

## If you like using the pipe operator you can do this: 
age_mo <- anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  )
```

Either way, you will get this: 

```{r usage.2a, echo = FALSE}
age_mo <- anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  )
head(age_mo)
```

### Getting all other data ready

You used `process_wfhz_data()` to get your input data ready to use in the plausibility checker. You achieve that as follows: 

```{r usage.2b, echo = TRUE, eval = FALSE}
processed_data <- anthro.01 |> 
  process_wfhz_data(
    sex = sex,
    weight = weight,
    height = height,
    .recode_sex = TRUE
  )
```

In this example, `.recode_sex` parameter was set to `TRUE`. That is because under the hood, to compute the z-scores, a task made possible thanks to the [zscorer](https://cran.r-project.org/web/packages/zscorer/index.htmlpackage) package, it uses sex coded into 1 and 2 for male and female respectively. This means that if your sex variable is already in 1 and 2's, you set `.recode_sex` to `FALSE` to tell the function to not re-code. On the other hand, if your sex variable is coded in any other way different than aforementioned, then you will have to re-code outside `ipccheckr` environment into one of the aforementioned code, and then set `.recode_sex` accordingly.

Back to what `process_wfhz_data()` does under the hood after re-coding (or not) sex, it computes z-scores and identify flags using the SMART flagging criteria, then it returns a data frame with two additional variables namely **wfhz** (storing the z-score with three decimal places) and **flag_wfhz** (telling if that particular observation is flag (1) or not (0), as you see below: 

```{r usage.2c, echo = FALSE}
processed_data <- anthro.01 |> 
  process_wfhz_data(
    sex = sex,
    weight = weight,
    height = height,
    .recode_sex = TRUE
  )

head(processed_data)
```

### On to *de facto* WFHZ plausibility check

Having done this, you are all set to check the plausibility of your data. You do that simply by calling the `check_plausibility_wfhz()` function as demonstrated: 

Following the approach in the above examples, you can just pass the already processed data object:

```{r usage.2d, echo = TRUE, eval = FALSE}
plausibility <- processed_data |> 
  check_plausibility_wfhz(
    sex = sex,
    age = age,
    weight = weight,
    height = height,
    flags = flag_wfhz,
    area = area
  )
```

Or you can chain all previous function with the pipe operator:

```{r usage.2e, echo = TRUE, eval = FALSE}
plausibility <- anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_wfhz_data(
    sex = sex,
    weight = weight,
    height = height,
    .recode_sex = TRUE
  ) |> 
  check_plausibility_wfhz(
    sex = sex,
    age = age,
    weight = weight,
    height = height,
    flags = flag_wfhz,
    area = area
  )

```

Either approach will give you this: 

```{r usage.2f, echo = FALSE}
anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_wfhz_data(
    sex = sex,
    weight = weight,
    height = height,
    .recode_sex = TRUE
  ) |> 
  check_plausibility_wfhz(
    sex = sex,
    age = age,
    weight = weight,
    height = height,
    flags = flag_wfhz,
    area = area
  )

```

The returned output is summary table grouped by district, with each districts statistics on the tests done and their respective classification. I think by now you do realize that the output is kind of what you used to construct by extracting details from each plausibility checks you used to run in ENA for SMART software one-by-one, travelling from ENA itself, to Microsoft Word and then to Excel back-and-forth. 

However this output is not yet pretty to share. To get that, you simply have to attach `generate_pretty_table_wfhz()` to the previous pipeline: 

```{r usage.2g, echo = TRUE, eval = FALSE}
anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_wfhz_data(
    sex = sex,
    weight = weight,
    height = height,
    .recode_sex = TRUE
  ) |> 
  check_plausibility_wfhz(
    sex = sex,
    age = age,
    weight = weight,
    height = height,
    flags = flag_wfhz,
    area = area
  ) |> 
  generate_pretty_table_wfhz()

```

This will give you: 

```{r usage.2h, echo = FALSE}
anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_wfhz_data(
    sex = sex,
    weight = weight,
    height = height,
    .recode_sex = TRUE
  ) |> 
  check_plausibility_wfhz(
    sex = sex,
    age = age,
    weight = weight,
    height = height,
    flags = flag_wfhz,
    area = area
  ) |> 
  generate_pretty_table_wfhz()

```

An already formatted table, with scientific notations converted into conventional notations, etc.

To this point, is end of WFHZ plausibility workflow. 

## Checking plausibility check on MUAC-for-age z-score

The MFAZ plausibility check was built based on the insights gotten from [Bilukha, O., & Kianian, B. (2023).](https://doi.org/10.1111/mcn.13478) paper presented at the [2023 High-Level Technical Assessment Workshop](https://smartmethodology.org/wp-content/uploads/2024/03/2023-High-level-Technical-Assessment-Workshop-Report.pdf) held in Nairobi, Kenya. This paper findings highlights that when using MFAZ, the same flagging criteria as that of WFHZ could be used, with a maximum plausibly percent of flags of 2.0%.

With `ipccheckr`, you can run MFAZ plausibility check using `check_plausibility_mfaz()`. Similar to WFHZ, you first have to get the data in the right shape and format that `check_plausibility_mfaz()` understands. First foremost, you have process age. You do this exactly the same way as demonstrated above in the WFHZ section. So this step (of demonstration) will be skipped here. 

#### An important note on age ratio test inside `check_plausibility_mfaz()`

As you know, the age ratio test in WFHZ is done on children aged 6:29 over 30-59 months. In MFAZ, the test is done on children aged 6:23 over 24-59 months as it is done in [SMART MUAC Tool](https://smartmethodology.org/survey-planning-tools/updated-muac-tool/), to detect for excess of younger children (6:23) in the sample. The output of this test is later used in the prevalence analysis to tell whether the age-weighting approach suggested in the SMART MUAC tool should be used or not. This is further demonstrated in the vignette about prevalence.  

### Getting MUAC data into the right format

This is the job of `process_muac_data()` function. You can use it as follows:

```{r usage.3, echo = TRUE, eval = FALSE}
anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  )
```

`process_muac_data()` works the in a similar way as `process_wfhz_data()` under the hood. It adds to the input data two new variables: **mfaz** and **flag_mfaz**. The former variables stores the z-score values of the MUAC-for-age index, whereas the latter variable stores data on whether a given observation is a flag (1) or not (0), based on SMART flags. 

So the above code returns: 

```{r usage.3a, echo = FALSE}
anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  )
```

**Important**: `process_muac_data()` accepts MUAC measurements in centimeters. That it takes the parameters `.recode_muac` and `unit`, to control on whether or not there is need to transform the variable MUAC into the units accepted inside `zscorer::addWGSR()` function that is in-charge of computing the z-scores. If your data set comes with `muac` variable in centimeters already, you set `.recode_muac` to `FALSE` and then `unit` to `"none"`. This will make the `muac` variable untouched. Either way, the returned data frame will always have `muac` variable in centimeters as shown below (an extract from the code above):

```{r usage.3b, echo=FALSE}
anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  ) |> 
  dplyr::select(muac)
```

Leaving this way will make downstream functions error as operations are performed on MUAC in millimeters. Thus, you must set it into to millimeters. `ipeccheckr` comes with a helper function `recode_muac()` to achieve this. You just need to use it inside `base::transform()` or `dplyr::mutate()` as follows: 

```{r usage.3c, echo = TRUE, eval = FALSE}
library(dplyr)

anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  ) |> 
  mutate(muac = recode_muac(muac, unit = "mm"))
  
```

In above code, inside `transform()` the `muac` variable is set to be re-coded to millimeters. 

This gives you: 

```{r usage.3d, echo = FALSE}

anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  ) |> 
  dplyr::mutate(muac = recode_muac(muac, unit = "mm")) |> 
  dplyr::select(muac)
  
```

### On to *de facto* MFAZ plausibility check

Up to the above stage, you are all set to pipe in the `check_plausibility_mfaz()`. So let's pipe it in the code below: 

```{r usage.3e, echo = TRUE, eval = FALSE}
library(dplyr)

anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  ) |> 
  mutate(muac = recode_muac(muac, unit = "mm")) |> 
  check_plausibility_mfaz(
    sex = sex,
    muac = muac,
    age = age,
    flags = flag_mfaz,
    area = area
  )
```

And this will return: 

```{r usage.3f, echo = FALSE}

anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  ) |> 
  dplyr::mutate(muac = recode_muac(muac, unit = "mm")) |> 
  check_plausibility_mfaz(
    sex = sex,
    muac = muac,
    age = age,
    flags = flag_mfaz,
    area = area
  )
```

`check_plausibility_mfaz()` also has its handy function to format the output table. Its called `generate_pretty_table_mfaz()`. This function takes only one parameter - the data frame returned by `check_plausibility_mfaz()`. Let's use it here: 

```{r usage.3g, echo = TRUE, eval = FALSE}
library(dplyr)

anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  ) |> 
  mutate(muac = recode_muac(muac, unit = "mm")) |> 
  check_plausibility_mfaz(
    sex = sex,
    muac = muac,
    age = age,
    flags = flag_mfaz,
    area = area
  ) |> 
  generate_pretty_table_mfaz()
```

This gives you this: 

```{r usage.3h, echo = FALSE}

anthro.01 |> 
  process_age(
    svdate = "dos",
    birdate = "dob",
    age = age
  ) |> 
  process_muac_data(
    sex = sex,
    muac = muac, 
    age = "age",
    .recode_sex = TRUE,
    .recode_muac = TRUE,
    unit = "cm"
  ) |> 
  dplyr::mutate(muac = recode_muac(muac, unit = "mm")) |> 
  check_plausibility_mfaz(
    sex = sex,
    muac = muac,
    age = age,
    flags = flag_mfaz,
    area = area
  ) |> 
  generate_pretty_table_mfaz()
```

To this point, you have reached the end of your workflow. 
